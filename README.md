# antro

This is a toy parser for an experimental programming language called _antro scripting language_ which is still in development. This project is purely educational (for now) as the language cannot be used for any industry work in its current form. Therefore, the sole aim of this project is to show and teach the skills required of designing computer languages and implementing them.

> The [**Regular Grammar**](https://github.com/coolandcodes/antro/blob/master/PARSER_ALGOS_AND_GRAMMAR.md#regular-grammar-productions-rgp-for-antro-scripting-language-tokenizer----ebnf) as details for the **Tokenizer** and the  [**Context-Free Grammar**](https://github.com/coolandcodes/antro/blob/master/PARSER_ALGOS_AND_GRAMMAR.md#context-free-grammar-productions-cfgp-for-antro-scripting-language-parser----ebnf) as production rules for the **Parser** (written in [EBNF](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form) format) as well as other details of the algorithm used to implement the recursive descent strategy of the parser.

## FrontEnd Design

-  **Tokenizer** (lexical analysis)
-  **Parser**  (semantic analysis)
-  **Executor** (a concurrent thread-safe queue for passing tokens from the **Tokenizer** to the **Parser** with a [lookahead of 1](https://www.quora.com/What-is-a-%E2%80%9Clookahead-operator%E2%80%9D-in-compiler-designs))

## Backend Design

No yet determined.

### What is a Regular Grammar ?

-  A regular grammar is the set of all strings generated by a grammar which all contain characters of the alphabet (or other single-character symbols) as defined by that grammar and which result to tokens (terminal symbols).

### What is a Context-Free Grammar ?

- A context-free grammar (CFG) is a set of recursive rewriting rules (or productions) used to generate patterns of strings. A CFG consists of the following components: a set of terminal symbols, which are the characters of the alphabet that appear in the strings generated by the grammar as well as a set of non-terminals.

## Sample program written in antro

```ada

	require: "sys.module";
	require: "errors.module";
	require: "logging.module";
	require: "types.module";

	def: MAX 200;

	begin: (void)
	  --# A novel programming language design for error handling (antro)
	  --# This uses chained exceptions behind the scenes (within the runtime).
	  var error = call: error("Program crashed");
	  var ty = call: factorUpBy2(MAX) -> eject_on error -> use {
 	    if (error) {
	      call: output(f"{error.message} - {error.context.cause}");
	    }
		
  	    call: print("A fatal error occurred");

		panic_on error;
	  };
	  call: print(ty);
	end;

	def: factorUpBy2(x){
	  var y, g = true;

	   if (x > 0) {
	     y = (x / 2) * 4;
	   } else {
	     g = false;
	   }

	    y = call: convertToFactor(g, x);
	    retn y
	};

	def: convertToFactor(c, d){
	  var error_message_prefix = "Argument type error: ";

	  --# before the `retn` statement below executes...
	  --# ... we call the invariants below ðŸ‘‡ðŸ¾ðŸ‘‡ðŸ¾
	  --# Antro builds invariants right into the...
	  --# ... programming model of the language ðŸ’¯
	  defer -> invariants {
	    error_message_prefix + "calling `convertToFactor(..)`",
		call: type(c, "number") -> eject_on $$;
 	    error_message_prefix + "calling `convertToFactor(..)`",
		call: type(d, "number") -> eject_on $$;
	  }

	  retn c * d;
	};

```

Though the above program doesn't do anything useful for now (i.e. the parser as currently written does not yet produce an Absract Syntax Tree - AST nor does it provide an Immediate Representation - IR), one can still get to understand the basics of what's going on.

## About

#### Module/File Imports
The `require` keyword is used to require/import a module (i.e. a folder) or a single source (i.e. a file) as an implicit dependency. For example, `require: "sys.module";` is a statement that requires/imports a folder named **"sys.module"**. This folder must dircetly contain a **root.antro** file. The folder can also contain other files and folders. 

#### Entry Point Definition
The `begin` keyword is used to defined the [**entry point**](https://en.wikipedia.org/wiki/Entry_point) of the _antro_ program. It is truncated by the `end` keyword.

#### Other Definitions
The  `def`  keyword is used to define variables in the **global scope** (i.e. outside functions) that cannot be changed. When using `def`, it doesn't matter if the variable is defined in a **global scope** or **local scope**, it will always be a **globally-scoped** variable. Also, variables created with the `def` keyword cannot have their values changed/mutated but only copied into a variable whose value can be changed/mutated. NOTE: Antro makes use of lexical scoping.

#### Variable Creation
The `var` keyword is used to define variables or functions within a **local scope** (i.e. within functions) only. When using the `var` keyword, it matters that it isn't used in a **global scope** (i.e. outside functions) else the _antro_ parser will throw a parse error. Also, variables created with the `var` keyword can have their value changed/mutated.

#### Exception Handling - Part 1
The `eject_on` keyword is the _antro_ equivalent of a [catch block](https://www.geeksforgeeks.org/try-catch-block-in-programming/#what-is-a-catchexcept-block) in other scripting languages like JavaScript. _Antro_ does not directly use the [try/catch](https://medium.com/@puran.joshi307/how-it-works-try-catch-61e90b18140a) model for error handling. It uses an error to catch other errors that occur higher up on the call stack. In this way, the [try/catch](https://medium.com/@puran.joshi307/how-it-works-try-catch-61e90b18140a) block [is abstracted away](https://github.com/isocroft/runn) from the source-level (hidden from the programmer) and handled by the _antro_ compiler and runtime.

#### Exception Handling - Part 2
The  `panic_on` keyword is the _antro_ equivalent of [panic](https://gobyexample.com/panic) keyword in [Golang](https://go.dev/) which triggers abandonment.

NOTE: Antro only has 2 broad classifications for errors:

- Recoverable Errors
- Non-recoverable Errors

#### Exception Handling - Part 3
The `use` keyword is the _antro_ equivalent of [finally](https://www.w3schools.com/java/ref_keyword_finally.asp) keyword in most c-based programming languages like Java, C#, Python or PHP

#### Invaraints
The `invariants` keyword is used to setup [invariants](https://softwareengineering.stackexchange.com/questions/32727/what-are-invariants-how-can-they-be-used-and-have-you-ever-used-it-in-your-pro) within a **local scope** (i.e. within functions). For the design of _antro_, i believe that [invariants](https://softwareengineering.stackexchange.com/questions/32727/what-are-invariants-how-can-they-be-used-and-have-you-ever-used-it-in-your-pro) ought to be baked into the programming model (i.e. the programming language). In the future, i plan to setup [macros](https://doc.rust-lang.org/book/ch20-05-macros.html) just like they are used in [Rust](https://www.rust-lang.org/) to make the `invariants` block shorter and more compact. All function definitions MUST contain an `invariants` block else the _antro_ runtime will throw an error.

#### Defering Action
The `defer` keyword is the _antro_ equivalent of the [defer](https://gobyexample.com/defer) keyword in [Golang](https://go.dev/).

#### Outputs
The `retn` keyword is used to return a value from a function definition or `begin` block.

## License 

This is released under the MIT license.

## Design Inspiration

Antro language design was inspired by Go, Rust, Python and JavaScript all combined.






